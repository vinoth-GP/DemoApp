/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeImageCropPickerPickerOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19, typename P20>
struct NativeImageCropPickerPickerOptions {
  P0 mediaType;
  P1 multiple;
  P2 includeBase64;
  P3 includeExif;
  P4 cropping;
  P5 width;
  P6 height;
  P7 cropperActiveWidgetColor;
  P8 cropperStatusBarLight;
  P9 cropperNavigationBarLight;
  P10 cropperToolbarColor;
  P11 cropperToolbarTitle;
  P12 cropperToolbarWidgetColor;
  P13 cropperCircleOverlay;
  P14 freeStyleCropEnabled;
  P15 showCropGuidelines;
  P16 showCropFrame;
  P17 hideBottomControls;
  P18 enableRotationGesture;
  P19 disableCropperColorSetters;
  P20 useFrontCamera;
  bool operator==(const NativeImageCropPickerPickerOptions &other) const {
    return mediaType == other.mediaType && multiple == other.multiple && includeBase64 == other.includeBase64 && includeExif == other.includeExif && cropping == other.cropping && width == other.width && height == other.height && cropperActiveWidgetColor == other.cropperActiveWidgetColor && cropperStatusBarLight == other.cropperStatusBarLight && cropperNavigationBarLight == other.cropperNavigationBarLight && cropperToolbarColor == other.cropperToolbarColor && cropperToolbarTitle == other.cropperToolbarTitle && cropperToolbarWidgetColor == other.cropperToolbarWidgetColor && cropperCircleOverlay == other.cropperCircleOverlay && freeStyleCropEnabled == other.freeStyleCropEnabled && showCropGuidelines == other.showCropGuidelines && showCropFrame == other.showCropFrame && hideBottomControls == other.hideBottomControls && enableRotationGesture == other.enableRotationGesture && disableCropperColorSetters == other.disableCropperColorSetters && useFrontCamera == other.useFrontCamera;
  }
};

template <typename T>
struct NativeImageCropPickerPickerOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mediaType)>(rt, value.getProperty(rt, "mediaType"), jsInvoker),
      bridging::fromJs<decltype(types.multiple)>(rt, value.getProperty(rt, "multiple"), jsInvoker),
      bridging::fromJs<decltype(types.includeBase64)>(rt, value.getProperty(rt, "includeBase64"), jsInvoker),
      bridging::fromJs<decltype(types.includeExif)>(rt, value.getProperty(rt, "includeExif"), jsInvoker),
      bridging::fromJs<decltype(types.cropping)>(rt, value.getProperty(rt, "cropping"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.cropperActiveWidgetColor)>(rt, value.getProperty(rt, "cropperActiveWidgetColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperStatusBarLight)>(rt, value.getProperty(rt, "cropperStatusBarLight"), jsInvoker),
      bridging::fromJs<decltype(types.cropperNavigationBarLight)>(rt, value.getProperty(rt, "cropperNavigationBarLight"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarColor)>(rt, value.getProperty(rt, "cropperToolbarColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarTitle)>(rt, value.getProperty(rt, "cropperToolbarTitle"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarWidgetColor)>(rt, value.getProperty(rt, "cropperToolbarWidgetColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperCircleOverlay)>(rt, value.getProperty(rt, "cropperCircleOverlay"), jsInvoker),
      bridging::fromJs<decltype(types.freeStyleCropEnabled)>(rt, value.getProperty(rt, "freeStyleCropEnabled"), jsInvoker),
      bridging::fromJs<decltype(types.showCropGuidelines)>(rt, value.getProperty(rt, "showCropGuidelines"), jsInvoker),
      bridging::fromJs<decltype(types.showCropFrame)>(rt, value.getProperty(rt, "showCropFrame"), jsInvoker),
      bridging::fromJs<decltype(types.hideBottomControls)>(rt, value.getProperty(rt, "hideBottomControls"), jsInvoker),
      bridging::fromJs<decltype(types.enableRotationGesture)>(rt, value.getProperty(rt, "enableRotationGesture"), jsInvoker),
      bridging::fromJs<decltype(types.disableCropperColorSetters)>(rt, value.getProperty(rt, "disableCropperColorSetters"), jsInvoker),
      bridging::fromJs<decltype(types.useFrontCamera)>(rt, value.getProperty(rt, "useFrontCamera"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String mediaTypeToJs(jsi::Runtime &rt, decltype(types.mediaType) value) {
    return bridging::toJs(rt, value);
  }

  static bool multipleToJs(jsi::Runtime &rt, decltype(types.multiple) value) {
    return bridging::toJs(rt, value);
  }

  static bool includeBase64ToJs(jsi::Runtime &rt, decltype(types.includeBase64) value) {
    return bridging::toJs(rt, value);
  }

  static bool includeExifToJs(jsi::Runtime &rt, decltype(types.includeExif) value) {
    return bridging::toJs(rt, value);
  }

  static bool croppingToJs(jsi::Runtime &rt, decltype(types.cropping) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperActiveWidgetColorToJs(jsi::Runtime &rt, decltype(types.cropperActiveWidgetColor) value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperStatusBarLightToJs(jsi::Runtime &rt, decltype(types.cropperStatusBarLight) value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperNavigationBarLightToJs(jsi::Runtime &rt, decltype(types.cropperNavigationBarLight) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarColorToJs(jsi::Runtime &rt, decltype(types.cropperToolbarColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarTitleToJs(jsi::Runtime &rt, decltype(types.cropperToolbarTitle) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarWidgetColorToJs(jsi::Runtime &rt, decltype(types.cropperToolbarWidgetColor) value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperCircleOverlayToJs(jsi::Runtime &rt, decltype(types.cropperCircleOverlay) value) {
    return bridging::toJs(rt, value);
  }

  static bool freeStyleCropEnabledToJs(jsi::Runtime &rt, decltype(types.freeStyleCropEnabled) value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropGuidelinesToJs(jsi::Runtime &rt, decltype(types.showCropGuidelines) value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropFrameToJs(jsi::Runtime &rt, decltype(types.showCropFrame) value) {
    return bridging::toJs(rt, value);
  }

  static bool hideBottomControlsToJs(jsi::Runtime &rt, decltype(types.hideBottomControls) value) {
    return bridging::toJs(rt, value);
  }

  static bool enableRotationGestureToJs(jsi::Runtime &rt, decltype(types.enableRotationGesture) value) {
    return bridging::toJs(rt, value);
  }

  static bool disableCropperColorSettersToJs(jsi::Runtime &rt, decltype(types.disableCropperColorSetters) value) {
    return bridging::toJs(rt, value);
  }

  static bool useFrontCameraToJs(jsi::Runtime &rt, decltype(types.useFrontCamera) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.mediaType) {
      result.setProperty(rt, "mediaType", bridging::toJs(rt, value.mediaType.value(), jsInvoker));
    }
    if (value.multiple) {
      result.setProperty(rt, "multiple", bridging::toJs(rt, value.multiple.value(), jsInvoker));
    }
    if (value.includeBase64) {
      result.setProperty(rt, "includeBase64", bridging::toJs(rt, value.includeBase64.value(), jsInvoker));
    }
    if (value.includeExif) {
      result.setProperty(rt, "includeExif", bridging::toJs(rt, value.includeExif.value(), jsInvoker));
    }
    if (value.cropping) {
      result.setProperty(rt, "cropping", bridging::toJs(rt, value.cropping.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.height) {
      result.setProperty(rt, "height", bridging::toJs(rt, value.height.value(), jsInvoker));
    }
    if (value.cropperActiveWidgetColor) {
      result.setProperty(rt, "cropperActiveWidgetColor", bridging::toJs(rt, value.cropperActiveWidgetColor.value(), jsInvoker));
    }
    if (value.cropperStatusBarLight) {
      result.setProperty(rt, "cropperStatusBarLight", bridging::toJs(rt, value.cropperStatusBarLight.value(), jsInvoker));
    }
    if (value.cropperNavigationBarLight) {
      result.setProperty(rt, "cropperNavigationBarLight", bridging::toJs(rt, value.cropperNavigationBarLight.value(), jsInvoker));
    }
    if (value.cropperToolbarColor) {
      result.setProperty(rt, "cropperToolbarColor", bridging::toJs(rt, value.cropperToolbarColor.value(), jsInvoker));
    }
    if (value.cropperToolbarTitle) {
      result.setProperty(rt, "cropperToolbarTitle", bridging::toJs(rt, value.cropperToolbarTitle.value(), jsInvoker));
    }
    if (value.cropperToolbarWidgetColor) {
      result.setProperty(rt, "cropperToolbarWidgetColor", bridging::toJs(rt, value.cropperToolbarWidgetColor.value(), jsInvoker));
    }
    if (value.cropperCircleOverlay) {
      result.setProperty(rt, "cropperCircleOverlay", bridging::toJs(rt, value.cropperCircleOverlay.value(), jsInvoker));
    }
    if (value.freeStyleCropEnabled) {
      result.setProperty(rt, "freeStyleCropEnabled", bridging::toJs(rt, value.freeStyleCropEnabled.value(), jsInvoker));
    }
    if (value.showCropGuidelines) {
      result.setProperty(rt, "showCropGuidelines", bridging::toJs(rt, value.showCropGuidelines.value(), jsInvoker));
    }
    if (value.showCropFrame) {
      result.setProperty(rt, "showCropFrame", bridging::toJs(rt, value.showCropFrame.value(), jsInvoker));
    }
    if (value.hideBottomControls) {
      result.setProperty(rt, "hideBottomControls", bridging::toJs(rt, value.hideBottomControls.value(), jsInvoker));
    }
    if (value.enableRotationGesture) {
      result.setProperty(rt, "enableRotationGesture", bridging::toJs(rt, value.enableRotationGesture.value(), jsInvoker));
    }
    if (value.disableCropperColorSetters) {
      result.setProperty(rt, "disableCropperColorSetters", bridging::toJs(rt, value.disableCropperColorSetters.value(), jsInvoker));
    }
    if (value.useFrontCamera) {
      result.setProperty(rt, "useFrontCamera", bridging::toJs(rt, value.useFrontCamera.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeImageCropPickerPickerResponse

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
struct NativeImageCropPickerPickerResponse {
  P0 path;
  P1 localIdentifier;
  P2 sourceURL;
  P3 filename;
  P4 width;
  P5 height;
  P6 mime;
  P7 size;
  P8 duration;
  P9 data;
  P10 exif;
  P11 cropRect;
  P12 creationDate;
  P13 modificationDate;
  bool operator==(const NativeImageCropPickerPickerResponse &other) const {
    return path == other.path && localIdentifier == other.localIdentifier && sourceURL == other.sourceURL && filename == other.filename && width == other.width && height == other.height && mime == other.mime && size == other.size && duration == other.duration && data == other.data && exif == other.exif && cropRect == other.cropRect && creationDate == other.creationDate && modificationDate == other.modificationDate;
  }
};

template <typename T>
struct NativeImageCropPickerPickerResponseBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.path)>(rt, value.getProperty(rt, "path"), jsInvoker),
      bridging::fromJs<decltype(types.localIdentifier)>(rt, value.getProperty(rt, "localIdentifier"), jsInvoker),
      bridging::fromJs<decltype(types.sourceURL)>(rt, value.getProperty(rt, "sourceURL"), jsInvoker),
      bridging::fromJs<decltype(types.filename)>(rt, value.getProperty(rt, "filename"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.mime)>(rt, value.getProperty(rt, "mime"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<decltype(types.data)>(rt, value.getProperty(rt, "data"), jsInvoker),
      bridging::fromJs<decltype(types.exif)>(rt, value.getProperty(rt, "exif"), jsInvoker),
      bridging::fromJs<decltype(types.cropRect)>(rt, value.getProperty(rt, "cropRect"), jsInvoker),
      bridging::fromJs<decltype(types.creationDate)>(rt, value.getProperty(rt, "creationDate"), jsInvoker),
      bridging::fromJs<decltype(types.modificationDate)>(rt, value.getProperty(rt, "modificationDate"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String pathToJs(jsi::Runtime &rt, decltype(types.path) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String localIdentifierToJs(jsi::Runtime &rt, decltype(types.localIdentifier) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sourceURLToJs(jsi::Runtime &rt, decltype(types.sourceURL) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String filenameToJs(jsi::Runtime &rt, decltype(types.filename) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String mimeToJs(jsi::Runtime &rt, decltype(types.mime) value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String dataToJs(jsi::Runtime &rt, decltype(types.data) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object exifToJs(jsi::Runtime &rt, decltype(types.exif) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object cropRectToJs(jsi::Runtime &rt, decltype(types.cropRect) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String creationDateToJs(jsi::Runtime &rt, decltype(types.creationDate) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String modificationDateToJs(jsi::Runtime &rt, decltype(types.modificationDate) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "path", bridging::toJs(rt, value.path, jsInvoker));
    if (value.localIdentifier) {
      result.setProperty(rt, "localIdentifier", bridging::toJs(rt, value.localIdentifier.value(), jsInvoker));
    }
    if (value.sourceURL) {
      result.setProperty(rt, "sourceURL", bridging::toJs(rt, value.sourceURL.value(), jsInvoker));
    }
    if (value.filename) {
      result.setProperty(rt, "filename", bridging::toJs(rt, value.filename.value(), jsInvoker));
    }
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "mime", bridging::toJs(rt, value.mime, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.duration) {
      result.setProperty(rt, "duration", bridging::toJs(rt, value.duration.value(), jsInvoker));
    }
    if (value.data) {
      result.setProperty(rt, "data", bridging::toJs(rt, value.data.value(), jsInvoker));
    }
    if (value.exif) {
      result.setProperty(rt, "exif", bridging::toJs(rt, value.exif.value(), jsInvoker));
    }
    if (value.cropRect) {
      result.setProperty(rt, "cropRect", bridging::toJs(rt, value.cropRect.value(), jsInvoker));
    }
    if (value.creationDate) {
      result.setProperty(rt, "creationDate", bridging::toJs(rt, value.creationDate.value(), jsInvoker));
    }
    if (value.modificationDate) {
      result.setProperty(rt, "modificationDate", bridging::toJs(rt, value.modificationDate.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeImageCropPickerCxxSpecJSI : public TurboModule {
protected:
  NativeImageCropPickerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value openPicker(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value openCamera(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value openCropper(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value clean(jsi::Runtime &rt) = 0;
  virtual jsi::Value cleanSingle(jsi::Runtime &rt, jsi::String path) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageCropPickerCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNCImageCropPicker";

protected:
  NativeImageCropPickerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageCropPickerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeImageCropPickerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageCropPickerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value openPicker(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openPicker) == 2,
          "Expected openPicker(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openPicker, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value openCamera(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openCamera) == 2,
          "Expected openCamera(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openCamera, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value openCropper(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openCropper) == 2,
          "Expected openCropper(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openCropper, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value clean(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clean) == 1,
          "Expected clean(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clean, jsInvoker_, instance_);
    }
    jsi::Value cleanSingle(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::cleanSingle) == 2,
          "Expected cleanSingle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cleanSingle, jsInvoker_, instance_, std::move(path));
    }

  private:
    friend class NativeImageCropPickerCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
